---
prev: ../redis-develop/1-install
---
# 简单动态字符串

> Redis没有直接使用C语言的字符串表示，而是构建了一套简单动态字符串(SDS)的抽象类型，并将SDS用作Redis的默认字符串表示

用途:

* 保存数据库中的字符串值(键或者字符串类型的值)
* AOF中的缓冲区以及客户端状态中的输入缓冲区

## 1. SDS的定义

```c
struct sdshdr {
    int len; 	    // buf 中已占用空间的长度(字符串的长度)
    int free; 		// buf 中剩余可用空间的长度
    char buf[];  	// 数据空间
};
```

* SDS遵循C字符串以空字符结尾(保存字符的1字节空间，不计算在SDS的len属性里面)；
* 为空字串分配1字节额外空间以及添加空字符到字符串末尾等操作都是由SDS函数自动完成的，对使用者完全透明；
* **直接重用一部分C字符串函数库里面的函数**（如printf等）。

## 2. 与C字符串的区别

> Clang使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组末尾总是空字符'\0'

### 2.1 常数复杂度获取字符串长度

c字符串获取长度需要O(n)时间，而SDS通过len可以直接获取。从O(n)降到了O(1)确保了获取字符串长度不会成为Redis的性能瓶颈。

### 2.2 杜绝缓冲区溢出

* C字符串不记录自身长度容易造成缓冲区溢出，如当使用strcat(char *dest, cont char *src)函数时，如果没有为dest分配足够多的内存(容纳不下src)就会发生缓冲区溢出；
* SDS的分配策略完全杜绝了发生缓冲区溢出的可能，当要修改SDS时，首先会检测SDS空间是否满足当前修改，不满足则自动扩容，然后执行操作。

### 2.3 减少修改字符串时带来的内存重分配次数

**C字符串**：

* 对于长度为N的C字符串来说，底层总是实现一个N+1长度的数组。因为C字符串的长度要和底层数组的长度之间存在着这种关联性，所以每次增长或缩短，都会进行以此内存重新分配；
    * 增长字符串：如拼接操作(append)，首先需要重新扩展底层数组空间的大小，如果忽略这一步就会造成**缓冲区溢出**
    * 缩短字符串：如截断操作(trim)，需要通过内存重分配来释放不使用的字符串，如果忽略这一步就会造成**内存泄露**
* 内存重分配涉及复杂的算法，可能需要执行系统调用，比较耗时。

**SDS**：

* **空间预分配**：当对字符串增长时，程序不仅会为SDS分配修改必要的空间，还会为SDS分配额外的未使用空间；

    * 如果SDS长度 < 1MB，那么程序会分配和len属性同样大小的未使用空间
    * 如果SDS长度 > 1MB，那么程序会分配30MB的空间

    * 通过空间预分配，Redis可以减少连续执行字符串增长操作所需要的内存分配次数

    * 通过这种预分配策略，SDS将连续增长N次字符串所需的内存重新分配次数从必定N次降为最多N次

* **惰性空间释放**：当需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节记录起来，以供将来使用。

### 2.4 二进制安全

* C字符串只能保存文本数据，不能保存图片，音频，视频，压缩文件这些二进制数据；
* SDS由于是二进制安全，不仅可以保存文本数据，还能保存任意格式的二进制数据。

### 2.5 兼容部分C字符串函数

可以使用Clang的<string.h>库，从而避免了不必要的代码重复。

## 3. 总结

| C字符串                                   | SDS                                        |
| ----------------------------------------- | ------------------------------------------ |
| 获取字符串长度的复杂度为0(N)              | 获取字符串长度的复杂度为0(1)               |
| API是二进制不安全的，可能会造成缓冲区溢出 | API是二进制安全的，不会造成缓冲区溢出      |
| 修改字符串长度N次必然需要执行N次内存分配  | 修改字符串长度N次最多执行N次内存分配       |
| 只能保存文本数据                          | 不仅能保存文本数据还能保存任意的二进制数据 |
| 可以使用<string.h>库中的函数              | 可以部分使用<string.h>库中的函数           |