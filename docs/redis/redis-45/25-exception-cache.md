# 缓存异常

## 1. 如何解决缓存不一致性？

### 1.1 数据一致性

* 缓存中有数据，并且和数据库中的数据保持一致
* 缓存中没有数据，数据库中的数据是最新的

### 1.2 数据不一致性

> 不满足上述两条

**读写缓存**

* 同步只写策略：写缓存时，也同步写数据库缓存和数据库的数据一致;
* 异步写回策略：写缓存时，不同步写数据库等数据，从缓存中淘汰时再写回数据库，如果还没写回数据库时缓存就发生了故障，那么回造成数据库不是最新据。
  
* 对于读写缓存要想保证数据一致性就要使用同步只写策略同时还要保证更新数据库和更新缓存具有原子性
* 如果我们对数据一致性要求不是那么高的话比如电商商品的非关键属性等可以使用异步写回策略

**只读缓存**

* 如果有数据新增，直接写入数据库
* 如果是数据更新，则只需将缓存标记为无效即可，以后访问会先读取数据库然后在写入缓存。

| 不同情况                 | 遇到的问题                                                   |
| ------------------------ | ------------------------------------------------------------ |
| 先更新数据库，后删除缓存 | 更新数据库成功，但是删除缓存失败，导致请求再次访问缓存时，缓存被命中，读取出来的数据是旧值。 |
| 先删除缓存，后更新数据库 | 删除缓存成功，但是更新数据库失败，导致请求访问缓存时，缓存不存在，从而读取数据库，读取出来的数据是旧值。 |

### 1.3 解决数据不一致问题

**重试机制**

* 将要删除的缓存和要更新的数据库信息，存入消息队列中，当更新或删除失败时，进行重试，当重试超过一定次数时，向业务层发送错误信息。如果更新或者删除成功要将消息队列中的数据删除，以避免重复消费。

**并发情况下**


* **先删除缓存，再更新数据库**

![](https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/image-20220330110216583.png)

**解决方案：延迟双删除，在线程A更新完数据值后， 让它sleep一小段时间，然后再进行以此删除缓存的操作**

> sleep原因：为了让线程B能够读取数据库的值然后更新到缺失的缓存中，然后线程A再删除，也就是线程A sleep的时间要长于线程B读取数据库和更新缓存的时间总和

* **先更新数据库，再删除缓存**

![](https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/image-20220330113608148.png)

> 如果其他线程并发读取缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程A一般也很快删除数据缓存，所以这种情况对业务影响比较小

**总结**

![](https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/image-20220330114423464.png)

**对于只读缓存来说，建议先更新数据库，再删除缓存。原因如下：**

* 先删除缓存再更新数据库，有可能导致有由于缓存确实而访问数据库，从而给数据库带来压力
* 如果业务中读取数据库和写缓存的时间不好估算，则延时双删中的sleep时间就不好设置。

## 2. 缓存雪崩

> 大量的应用请求无法在redis缓存中进行处理，大量请求直接打在了数据库层，从而导致数据库压力激增，甚至引发数据库宕机。与缓存击穿不同的是击穿是并发查询同一条数据，雪崩是大量的不同的数据过期，从而直接查询数据库。

### 2.1 原因

* **缓存中有大量数据同时过期，导致大量请求无法得到处理**

* **Redis实例宕机**

### 2.2 解决

**1. 大量数据同时过期**：

* 设置过期时间的时候可以给key**加上较小的随机时间**(1~3分钟)，这样既避免了所有数据不会同一时间内过期也保证在数据基本在相近的时间内过期，仍然满足了业务需求。

* **服务降级**
  * 当业务访问的是非核心数据时，暂停从缓存中查询，直接返回预定义信息，或者是空值。
  * 当业务访问的核心数据是，允许查询缓存，如果缓存缺失则可以继续查询数据库。

**2. Redis实例宕机**：

* 在业务系统中实现**服务熔断**或者**限流机制**

  * **服务熔断**：指定是在发生缓存雪崩时，为了防止引发连锁的数据库雪崩，甚至是系统的崩溃，我们暂停对缓存系统的接口访问。虽然可以保证数据库可以正常运行，但是暂停了整个缓存系统的访问，对业务影响较大，应避免使用。
  * **限流机制**：在入口处进行限流，从而降低数据库的压力

![](https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/image-20220330155650747.png)

* **提前预防： 通过主从结点的方式构建高可用的集群**

## 3. 缓存击穿

> 指的是缓存中没有数据但是数据库中有数据，造成了访问该数据的大量请求一下次发送到数据库层处理，导致了数据库性能下降。通常发生在过期时间失效的情况下。

**对于频繁访问的数据不加过期时间**

## 4. 缓存穿透

> 指的是数据既不在缓存中又不在数据库中，例如用户不断发起id = -1的查询，这时可能会导致数据库压力过大

### 4.1 原因

* 业务层误操作：缓存和数据库中的数据被误删了
* 恶意攻击：专门访问数据库中没有的数据

### 4.2 解决

* **缓存空值或缺省值**
* **布隆过滤器**：在缓存中快速判断key是否存在

### 4.3 布隆过滤器原理：

**布隆过滤器**：是由一个初值为0的bit数组和多个hash函数组成，可以用来快速判断某个数据是否存在。

**标记步骤**：

* 首先，使用N个hash函数，分别计算这个数据的hash值，得到N个hash值
* 然后，把这N个hash值对bit数组的长度取模，得到每个hash值在数组中的位置
* 最后，把对应位置的bit设置为1，至此我们就完成了对数据的标记

![](https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/image-20220330182118750.png)

## 5. 总结

![](https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/image-20220330182154242.png)