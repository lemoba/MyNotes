# InnoDB数据页结构

> 页是InnnoDB管理存储空间的基本单位，一个页的大小一般是16KB

## 1. 数据页的结构

<img src="https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/20220604195047.png" style="zoom:50%;" />

## 2. 记录在页中的存储

新生成的页并没有User Records(heap)，每当插入一条新纪录时，都会从FreeSpace部分申请一个记录大小的空间，当FreeSpace的空间被用完时，就需要去申请新的页了。

**记录头信息**

| 名称         | 大小(比特) | 描述                                                         |
| ------------ | ---------- | ------------------------------------------------------------ |
| deleted_flag | 1          | 标记该记录是否被删除                                         |
| min_rec_flag | 1          | B+树中每层非叶子节点中的最小的目录项记录都会添加该标记       |
| n_owned      | 4          | 一个页面的记录会被分为若干个组，每个组的master记录的n_owned属性代表改组中的所有记录数，其他记录的n_owned值都为0 |
| heap_no      | 13         | 表示当前记录在页面堆中相对位置                               |
| record_type  | 3          | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点的目录项记录，2表示Infimum记录，3表示Supremum记录 |
| next_record  | 16         | 表示下一条记录的相对位置                                     |

* InnoDB规定，任何用户记录都比Infimum记录大，任何用户记录都比Supermum记录小
* 删除记录时，并不会直接从存储空间中移除，而是把该条记录的deleted_flag值设置为1， 并将被删除记录的record_type的值设置为0
* 当数据页中存在多条被删除的记录时，可以使用这些记录的next_record属性将这些被删除的记录组成一个垃圾链表，以备后续重用这部分存储空间、、、

## 3. Page Directory(页目录)

> 将页中的记录划分分组以方便快速查找

**划分过程**

* 将所有正常的记录(Infimum和Supermum记录，但不包括已经移除到垃圾链表的记录)划分为几个分组
* 每个组的最后一条记录最为master记录，其他记录作为普通记录，master记录的头信息中的n_owned属性表示该组内共有几条记录
* 将每个组中最后一条记录在页面中的地址偏移量单独提取出来，按顺序存储到靠近页尾的地方，这个地方就是page directory。页目录中的这些地址偏移量称为槽(Slot)，每个槽占用2字节，页目录是由多个槽组成



* Infimum记录的n_owned值为，这表示以Infimum记录为最后一节点的这个分组中只有一个记录就是它本身

* Supermum记录n_owned的值为它本身一条记录加上存储的用户记录

* 槽记录越小，它就越靠近File Trailer

    

**分组记录依据**

* 对于Infimum记录所在的分组只能有1条记录
* Supremum记录所在的分组记录条数只能在1~8条之间
* 剩下分组中记录的条数的范围只能在4~8条之间

**分组过程**

* 在初始情况下，一个数据页只有Infimum记录和Supremum记录这两条，它们分属于两个分组，页目录中也只有两个槽
* 之后每插入一条记录，都会从页目录中找到对应记录的主键值比待插入记录的主键值大并且差值最小的槽(槽是一个组内最大的那条记录在页面中的地址偏移量)，然后把该槽对应记录的n_owned值+1，表示本组内又添加一条记录。

**查找数据的过程**

* 通过二分法确认该记录所在分组对应的槽，然后找到该槽所在分组中主键值最小的那条记录

    > 每个槽对应的记录都是本分组内主键值最大的记录，但是槽与槽是相连的，可以找到最大槽前一个槽，然后通过next_record即可找到目标槽最小的记录值

* 通过记录的next_record属性遍历槽所在组中的各个记录

## 4. Page Header(页面头部)

> 专门用来存储数据页中记录的状态信息(已存储了多少记录、页目录中存储了多少个槽等)，占用固定的56字节

| 状态名称          | 占用空间大小(Byte) | 描述                                                         |
| ----------------- | ------------------ | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2                  | 在页目录中的槽数量                                           |
| PAGE_N_TOP        | 2                  | 还未使用的空间最小地址，也就是说从该地址之后就是Free Space   |
| PAGE_N_HEAP       | 2                  | 第1位表示本记录是否为紧凑型的记录，剩余的15位表示本页的堆中记录的数量(Infimum、Supermum、标记为'已删除'的记录) |
| PAGE_FREE         | 2                  | 各个已删除记录通过的next_record组成一个单向链表，PAGE_FREE表示该链表头节点对应记录所在页面中的偏移量 |
| PAGE_LAST_INSERT  | 2                  | 最后插入记录的位置                                           |
| PAGE_GARBAGE      | 2                  | 已删除记录占用的字节数                                       |
| PAGE_DIRECTION    | 2                  | 记录插入的方向                                               |
| PAGE_N_DIRECTION  | 2                  | 一个方法连续插入的记录数量                                   |
| PAGE_N_RECS       | 2                  | 该页中用户记录的数量(不包括Infimum、Supermum、标记为'已删除'的记录) |
| PAGE_MAX_TRX_ID   | 8                  | 修改当前页的最大事务id，该值仅在二级索引页面中定义           |
| PAGE_LEVEL        | 2                  | 当前页的B+树所处的层级                                       |
| PAGE_BTR_SEG_LEAF | 10                 | B+树叶子节点段的头部信息，仅在B+树的根页面中定义             |
| PAGE_BTR_SEG_TOP  | 10                 | B+树非叶子节点段的头部信息，仅在B+树的根页面中定义           |
| PAGE_INDEX_ID     | 8                  | 索引ID，表示当前页属于哪个索引                               |

* PAGE_DIRECTION：假如新插入的一条记录的主键值比上一条记录的主键值大，我们就说这个记录的插入方法是右边，反之则是左边

* PAGE_N_DIRECTION：假设连续几次插入新纪录的方法是一致的，InnoDB会把沿着同一个方向插入记录的条数用PAGE_N_DIRECTION记录下来，一旦记录插入的方向发生了改变，这个状态值就会被重新统计

## 5. File Header(文件头部)

> 用来记录一些通用于各种也得信息(页编号，上一页和下一页是谁)

| 状态名称                         | 占用空间大小(Byte) | 描述                                                         |
| -------------------------------- | ------------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4                  | 当MySQL版本低于4.0.14时，改属性表示本页面所在表空间ID；在之后的版本中，该属性表示页的校验和(checksum) |
| FIL_PAGE_OFFSET                  | 4                  | 页号                                                         |
| FIL_PAGE_PREV                    | 4                  | 上一个页的页号                                               |
| FIL_PAGE_NEXT                    | 4                  | 下一个页的页号                                               |
| FIL_ PAGE_LSN                    | 8                  | 页面被最后修改时对应的LSN(log sequence number，日志序列号)值 |
| FIL_PAGE_TYPE                    | 2                  | 该页的类型                                                   |
| FIL_PAGE_FILE_FLUSH_LSN          | 8                  | 仅在系统表空间的第一个也中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4                  | 页属于哪个表空间                                             |

* FIL_PAGE_OFFSET：每一个页都有一个单独的页号，InnoDB通过页号来唯一确定一个页
* FIL_PAGE_TYPE：表示当前页类型
* FIL_PAGE_PREV和FIL_PAGE_NEXT：通过建立一个双向链表就可以把众多的页串联起来(逻辑上有序)

## 6. File Trailer(文件尾部)

> 用来检测页是否完整，由8字节组成

在将页从内存刷到磁盘时，为了保证也得完整性，页首和页尾都会存储页中数据的校验和，以及页面最后修改时对应的LSN值(页尾只会存储LSN值的后4个字节)。如果页首和页尾和以及LSN值校验不成功，就说明刷新期间出现了问题。
