# 索引

## 1. 目录项

在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：**下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为页分裂**

<img src="https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/20220605160655.png" style="zoom:50%;" />

**每个目录项包括下面两个部分**

* 页的用户记录中最小的主键值
* 页号

## 2. 索引

### 2.1 什么是索引？

索引是一种特殊的数据结构，依靠某些数据结构和算法，最终引导用户快速检索出所学要的数据

### 2.2 一些概念

**磁盘中数据的读取**

* **扇区**：磁盘存储的最小单位，扇区一般大小为512Byte
* **磁盘块**：文件系统与磁盘交互的最小单位(计算机系统读写磁盘的最小单位)，一个磁盘块由连续几个(2^n)扇区组成，块一般大小一般为4KB
* **磁盘读取数据：**磁盘读取数据是靠机械运动，每次花费的时间可分为**寻道时间**、**旋转延迟**、**传输时间**三个部分

**mysql中的页**

mysql中和磁盘交互的最小单位称为页，页是mysql内部定义的一种数据结构，默认16kb，相当于4个磁盘块

### 2.3 如何查找数据？

**查找算法**

* **循环遍历**

​	n条数据，时间复杂度为O(n)，最快需要1次，最坏情况下需要n次，查询效率不稳定

* **二分查找**

 	二分查找又称折半查找，前提是数组是有序的

**存储结构**

* **有序数组**

    > 需要取出表中所有数据，存放在一个有序数组中，所耗费的io次数太多；如果数据很多，从磁盘加载到内存中需要的内存也很大，为了保证数据有序，插入的数据会涉及到数组内存数据的移动，浪费性能。

    * **优点**：可以通过下标随机访问数据
    * **缺点**：删除、增加非尾部数据时需要大量移动元素

* **链表**
    * **单链表**：每个节点中都有一个指向下一个节点的指针，只能安装一个方向遍历链表
    * **双向链表**：每个节点都有一个指向上一个节点的指针和指向下一个节点的指针
    * **优点**
        * 可以快速定位到上一个或者下一个节点
        * 可以快速删除数据，只需要改变指针的指向即可
    * **缺点**
        * 无法像数组那样通过下标随机访问数据
        * 查找数据是必须要从头节点开始遍历整个链表，最差时间复杂度为O(n)
    
* **二叉查找树**

    > 二叉树是的每个结点最多有两个子树的树结构，通过子树被称作"左子树"和"右子树"

    | <img src="https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/image-20220605164754537.png" style="zoom:50%;" /> | <img src="https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/image-20220605164802675.png" style="zoom:30%;" /> |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    
    
    
    * **性质**
        * 每个结点都包含一个元素以及n各子树(0<=n<=2)
        * 左子树和右子树是有顺序的，左子树的值要小于父节点，右子树的值要大于父节点
    * **优缺点**
        * 查询数据的效率不稳定，若左右子树相对平衡时，最差情况为O(logN)，如果插入数据是有序的，退化为了链表，查询时间为O(N)
        * 当数据量比较大的时候，会导致树的高度变高，因此io次数会大幅度增高
    
* **平衡二叉树(AVL树)**

    > 平衡二叉树是一种特殊的二叉树，满足二叉查找树的特性，同时它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

    * **优缺点**
        * 查找速率比较稳定，时间复杂度O(logN)
        * 当数据量比较大的时候，会导致树的高度变高

* **B-树**(下图左边)

    > 是一个多叉树，一个节点可以存储多个元素，目的是降低树的高度

    * **特性**
        * 每个节点最多有m个孩子，m称为b树的阶
        * 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子
        * 若根节点不是叶子节点，则至少有2个孩子
        * 所有叶子节点都在同一层，且不包含其它关键字信息
        * 每个非终端节点包含n个关键字（健值）信息
        * 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1
        *  ki(i=1,…n)为关键字，且关键字升序排序
        * Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大 于k(i-1)
    
    * **优缺点**
        * 非叶子节点也存储数据，在进行区间查询的时候需要访问多个磁盘块，增加了io次数
        * 内部数据有序，可以使用二分查找快速定位

| <img src="https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/20220605165836.png" style="zoom:80%;" /> | <img src="https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/20220605170532.png" style="zoom:50%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

* **B+树**(上图右边)

    > 与B-树不同的是B+树的数据都是存放在叶子节点上，非叶子节点只存储页号和每个目录页中记录的最小值

    * **特性**
        *  每个结点至多有m个子女
        * 除根结点外,每个结点至少有[m/2]个子女，根结点至少有两个子女
        * 有k个子女的结点必有k个关键字
        * 父节点中持有访问子节点的指针
        * 父节点的关键字在子节点中都存在（如上面的1/20/35在每层都存在），要么是最小值，要么是最 大值，如果节点中关键字是升序的方式，父节点的关键字是子节点的最小值
        * 最底层的节点是叶子节点
        *  除叶子节点之外，其他节点不保存数据，只保存关键字和指针
        * 叶子节点包含了所有数据的关键字以及data，叶子节点之间用链表连接起来，可以非常方便的支 持范围查找

### 2.4 B+树和B-树的区别？

* B+树中一个节点如果有k个关键字，最多可以包含k个子节点(k个关键字对应k个指针)；而B-树对应k+1个子节点(多了一个指向子节点的指针)
*  B+树除叶子节点之外其他节点值存储关键字和指向子节点的指针，而B-树还存储了数据，这样同样大小情况下，B+树可以存储更多的关键字
*  B+树叶子节点中存储了所有关键字及data，并且多个节点用链表连接，从上图中看子节点中数据 从左向右是有序的，这样快速可以支撑范围查找（先定位范围的最大值和最小值，然后子节点中依 靠链表遍历范围数据）



### 2.5 B-树和B+树该如何选择？

* B-树因为非叶子结点也保存具体数据，所以在查找某个关键字的时候找到即可返回。而B+Tree 所有的数据都在叶子结点，每次查找都得到叶子结点。所以在同样高度的B-树和B+树中，BTree查找某个关键字的效率更高
* 由于B+树所有的数据都在叶子结点，并且结点之间有指针连接，在找大于某个关键字或者小于 某个关键字的数据的时候，B+树只需要找到该关键字然后沿着链表遍历就可以了，而B-树还 需要遍历该关键字结点的根结点去搜索
* 由于B-树的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而B+树非 叶子结点只存储关键字信息，而每个页的大小有限是有限的，所以同一页能存储的B-树的数据会 比B+树存储的更少。这样同样总量的数据，B-树的深度会更大，增大查询时的磁盘I/O次数， 进而影响查询效率

## 3. InnoDB的索引

**聚簇索引(主键索引)：** 以主键值的大小作为页和记录的排序规则，在叶子节点处存储的记录包含表中所有的列

**二级索引(辅助索引)**：以索引列的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是索引列+主键

**数据检索过程**

* **根据主键查询**：只需要在局促索引中检索

* **根据辅助索引查询**：

    * 现在辅助索引中检索数据，获取主键值
    * 然后再到聚簇索引上查询主键值对应的记录

    以上这个过程叫做**回表**

<img src="https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/20220605172830.png" style="zoom:50%;" />

## 4. MyISAM引擎中的索引

MyISAM使用的非聚集索引，如图所示，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两个B+树的叶子结点都用一个地址指向真正的表数据。由于索引树是独立的，通过辅助键检索无需访问主键的索引树

**数据检索过程**

* 在索引中找到对应的关键字，获取关键字对应的记录的地址
* 通过记录的地址查找到对应的数据记录

## 5. 索引管理

### 5.1 索引分类

* **聚簇索引(聚集索引/主键索引)**

​	每个表有且一定会有一个聚簇索引，整个表的数据存储在聚簇索引中，mysql索引采用B+树结构保存在文件中，叶子节点存储主键的值以及对应的数据，非叶子节点不存储记录数据，只存储主键值和指针。当表中未指定主键时，mysql内部会自动给每条记录添加一个隐藏的rowid字段(默认为4字节)作为主键，用来构建聚集索引

* **二级索引(辅助索引/非聚集索引)**

​	也是B+树结构，和聚簇索引不同的是，二级索引叶子节点值存储索引字段和主键值，非叶子节点只存储索引字段

* **单列索引**：一个索引只包含一个列

* **多列索引(复合索引)**：一个索引包含一个列
* **唯一索引**：索引的值必须唯一，但允许有空值

### 5.2 使用索引

* **创建索引**

> 如果字段是char、varchar类型，length可以小于字段实际长度，如果是blog、text等长文本类 型，必须指定length。 
>
> [unique]：中括号代表可以省略，如果加上了unique，表示创建唯一索引。 
>
> 如果table后面只写一个字段，就是单列索引，如果写多个字段，就是复合索引，多个字段之间用 逗号隔开。

```sql
create [unique] index 索引名称 on 表名(列名[(length)]);

alter 表名 add [unique] index 索引名称 on (列名[(length)]);
```

* **删除索引**

```sql
drop index 索引名称 on 表名;
```

* **查看索引**

```sql
show index from 表名;
```

* **索引修改**：先删除再添加

## 6. 如果正确使用索引

