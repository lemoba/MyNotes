(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{515:function(s,t,a){"use strict";a.r(t);var e=a(11),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[s._v("#")]),s._v(" 持久化")]),s._v(" "),a("blockquote",[a("p",[s._v("Redis支持RDB和AOF两中持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件计科实现数据恢复。")])]),s._v(" "),a("h2",{attrs:{id:"_1-rdb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-rdb"}},[s._v("#")]),s._v(" 1. RDB")]),s._v(" "),a("blockquote",[a("p",[s._v("RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。")])]),s._v(" "),a("h3",{attrs:{id:"_1-1-触发机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-触发机制"}},[s._v("#")]),s._v(" 1.1 触发机制")]),s._v(" "),a("p",[a("strong",[s._v("手动触发")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("save命令")]),s._v("：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，不建议线上环境使用。")]),s._v(" "),a("li",[a("strong",[s._v("bgsave命令")]),s._v("：Redis当前进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只会发送在fork阶段。")])]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" bgsave\nBackground saving started\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" save\nOK\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 日志输出")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# bgsave")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25522")]),s._v(":M "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" May "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2022")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("14")]),s._v(":44:37.116 * Background saving started by pid "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10276")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10276")]),s._v(":C "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" May "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2022")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("14")]),s._v(":44:37.120 * DB saved on disk\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10276")]),s._v(":C "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" May "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2022")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("14")]),s._v(":44:37.121 * RDB: "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" MB of memory used by copy-on-write\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25522")]),s._v(":M "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" May "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2022")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("14")]),s._v(":44:37.187 * Background saving terminated with success\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# save")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25522")]),s._v(":M "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" May "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2022")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("14")]),s._v(":49:26.342 * DB saved on disk\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[a("em",[s._v("bgsave命令是针对save阻塞问题做出的优化。因此Redis内部所有的涉及RDB的操作都采用bgsave的方式。")])]),s._v(" "),a("p",[a("strong",[s._v("自动触发")])]),s._v(" "),a("ul",[a("li",[s._v('"Save m n"：表示m秒内数据集存在n次修改时，自动触发bgsave')]),s._v(" "),a("li",[s._v("如果节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点")]),s._v(" "),a("li",[s._v("执行debug reload命令重载Redis时，也会自动触发save操作")]),s._v(" "),a("li",[s._v("默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave")])]),s._v(" "),a("h3",{attrs:{id:"_1-2-bgsave流程说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-bgsave流程说明"}},[s._v("#")]),s._v(" 1.2 bgsave流程说明")]),s._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/20220517150743.png"}}),s._v(" "),a("p",[a("strong",[s._v("1.")]),s._v(" "),a("strong",[s._v("执行bgsave命令")]),s._v("，Redis父进会判断当前是否存在正在执行的子进程，如RDB/AOF子进程，存在则直接返回。")]),s._v(" "),a("p",[a("strong",[s._v("2.")]),s._v(" "),a("strong",[s._v("父进程fork子进程")]),s._v("，fork操作会阻塞父进程，通过info stats命令查看latest_fork_usec选项，获取耗时(微秒)。")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" info stats\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Stats")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\nlatest_fork_usec:318\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[a("strong",[s._v("3.")]),s._v(" 父进程完成后，结束阻塞，继续响应其他命令。")]),s._v(" "),a("p",[a("strong",[s._v("4. 子进程创建RDB文件")]),s._v("，根据父进程内存生成临时快照文件，完成后对原有文件进行"),a("strong",[s._v("原子替换。")])]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 最后一次生成RDB的时间")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" lastsave\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1652770166")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" info persistence\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Persistence")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\nrdb_last_save_time:1652770166\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[a("strong",[s._v("5.")]),s._v(" 进程发送信号给父进程表示完成，父进程更新统计信息。(使用info persistence查看)")]),s._v(" "),a("h3",{attrs:{id:"_1-3-rdb文件的处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-rdb文件的处理"}},[s._v("#")]),s._v(" 1.3 RDB文件的处理")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("保存")]),s._v("：RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配置指定。可通过config set dir {newDir} 和config set dbfilename {newFileName}运行期动态执行。当下次运行时RDB文件会保存到新目录。")]),s._v(" "),a("li",[a("strong",[s._v("压缩")]),s._v("：Redis默认采用LZF算法对RDB文件进行压缩处理，可通过config set rdbcompression {yes|no}动态修改。")]),s._v(" "),a("li",[a("strong",[s._v("校验")]),s._v("：Redis提供redis-check-rdp工具检测RDB文件并获取对应的错误信息。")])]),s._v(" "),a("h3",{attrs:{id:"_1-4-rdb的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-rdb的优缺点"}},[s._v("#")]),s._v(" 1.4 RDB的优缺点")]),s._v(" "),a("p",[a("strong",[s._v("优点：")])]),s._v(" "),a("ul",[a("li",[s._v("RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。如每6个小时执行bgsave备份，并上传到远程机器上用于灾难恢复。")]),s._v(" "),a("li",[s._v("Redis加载RDB恢复数据远远快于AOF的方式。")])]),s._v(" "),a("p",[a("strong",[s._v("缺点")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("RDB方式数据无法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。")]),s._v(" "),a("li",[s._v("RDB文件使用特定二进制格式保存，Redis演进过程中存在多个版本的RDB，可能存在老版本Redis无法兼容新版RDB格式的问题。")])]),s._v(" "),a("h2",{attrs:{id:"_2-aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-aof"}},[s._v("#")]),s._v(" 2. AOF")]),s._v(" "),a("blockquote",[a("p",[s._v("以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令以达到恢复数据的目的")])]),s._v(" "),a("h3",{attrs:{id:"_2-1-使用aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-使用aof"}},[s._v("#")]),s._v(" 2.1 使用AOF")]),s._v(" "),a("ul",[a("li",[s._v("默认不开启，如果要开启需要设置：appendonly yes")]),s._v(" "),a("li",[s._v("AOF文件名通过appendfilename来设置，默认文件名是appendonly.aof")]),s._v(" "),a("li",[s._v("保存路径通过dir来设置")])]),s._v(" "),a("p",[a("strong",[s._v("AOF的工作流程如下图所示：")])]),s._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://mynotes-1252832980.cos.ap-shanghai.myqcloud.com/20220601192824.png"}}),s._v(" "),a("ul",[a("li",[s._v("所有的写入命令会追加到aof_buf(缓冲区)中")]),s._v(" "),a("li",[s._v("AOF缓冲区根据对应的策略向硬盘做同步操作")]),s._v(" "),a("li",[s._v("随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的")]),s._v(" "),a("li",[s._v("当redis服务器重启时，可以加载AOF文件进行数据恢复")])]),s._v(" "),a("h3",{attrs:{id:"_2-2-写命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-写命令"}},[s._v("#")]),s._v(" 2.2 写命令")]),s._v(" "),a("blockquote",[a("p",[s._v("AOF命令写入的内容直接是文本协议格式")])]),s._v(" "),a("p",[a("strong",[s._v("为什么采用文本协议？")])]),s._v(" "),a("ul",[a("li",[s._v("文本协议具有很好的兼容性")]),s._v(" "),a("li",[s._v("开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销")]),s._v(" "),a("li",[s._v("文本协议具有可读性，方便直接修改和处理")])]),s._v(" "),a("p",[a("strong",[s._v("AOF为什么把命令追加到aof_buf中?")])]),s._v(" "),a("ul",[a("li",[s._v("Redis使用单线程相应命令，如果每次写入AOF文件命令都追加到硬盘，那么性能完全取决于当前硬盘负载")]),s._v(" "),a("li",[s._v("Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡")])]),s._v(" "),a("h3",{attrs:{id:"_2-3-文件同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-文件同步"}},[s._v("#")]),s._v(" 2.3 文件同步")]),s._v(" "),a("blockquote",[a("p",[s._v("Redis提供了多种AOF缓冲区同步文集策略，由参数appendfsync控制")])]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[s._v("可配置值")]),s._v(" "),a("th",{staticStyle:{"text-align":"left"}},[s._v("说明")])])]),s._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[s._v("always")]),s._v(" "),a("td",{staticStyle:{"text-align":"left"}},[s._v("命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回")])]),s._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[s._v("everysec")]),s._v(" "),a("td",{staticStyle:{"text-align":"left"}},[s._v("命令写入aof_buf后调用系统write操作，write完成后线程返回。fsync同步文件操作由专门线程每秒调用一次")])]),s._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[s._v("No")]),s._v(" "),a("td",{staticStyle:{"text-align":"left"}},[s._v("命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒")])])])]),s._v(" "),a("ul",[a("li",[a("p",[s._v("配置为always时，每次写入都要同步AOF文件，其性能取决于硬盘速度，与Redis高性能特性背道而驰，不建议配置")])]),s._v(" "),a("li",[a("p",[s._v("配置为no， 由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证")])]),s._v(" "),a("li",[a("p",[s._v("配置为everysec，建议的同步策略，也是默认配置，能做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据")])])]),s._v(" "),a("h3",{attrs:{id:"_2-4-重写机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-重写机制"}},[s._v("#")]),s._v(" 2.4 重写机制")]),s._v(" "),a("blockquote",[a("p",[s._v("AOF文件重写是把Redis进程内的数据转化为写命令同步到新的AOF文件的过程")])]),s._v(" "),a("p",[a("strong",[s._v("为什么要重写？")])]),s._v(" "),a("p",[s._v("AOF重写除了降低文件占用的空间，另外更小的AOF文件可以更快地被Redis加载。")]),s._v(" "),a("p",[a("strong",[s._v("重写后的AOF文件为什么可以变小")])]),s._v(" "),a("ul",[a("li",[s._v("进程内已经超时的数据不再写入文件")]),s._v(" "),a("li",[s._v("旧的AOF文件含有无效命令(del key1、hdel key2、srem keys等)，重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令")]),s._v(" "),a("li",[s._v("多条写命令可以合并为一个(lpush list a、lpush list b、lpush list c 可以转换为：lpush list a b c)。为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型操作，以64个元素为届拆分为多条")])])])}),[],!1,null,null,null);t.default=n.exports}}]);